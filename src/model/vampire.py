from subprocess import PIPE, STDOUT, Popen, run

class VampireWrapper:

	def __init__(self, vampirePath):
		self.vampireProcess = None # Process | None
		self.vampireState = None # "running" | "saturation" | "refutation" | "error" | "timeout" | None

		self.optionsForVisualization = ["-av", "off", "--show_preprocessing", "on", "--show_new", "on", "--show_active", "on", "--show_reductions", "on", "--proof_extra", "full"]
		self.vampirePath = vampirePath

	# run Vampire fully automatically on the given input file, and return all the output generated by Vampire
	def start(self, inputFile, userOptions):
		if self.vampireProcess != None:
			self.vampireProcess.kill()

		# note: if an option is supplied twice, Vampire ignores the first occurence
		#       we therefore add the user options first, so that user options conflicting
		#       with visualization options are ignored
		args = [self.vampirePath]
		args.extend(userOptions.split())
		args.extend(self.optionsForVisualization)
		args.append(inputFile)

		output = run(args, stdout=PIPE, stderr=STDOUT, text=True).stdout

		lines = output.replace('\r\n', '\n').replace('\r', '\n').split('\n')
		state = "none"
		for line in lines:
			if line.startswith("% Refutation found. Thanks to"): # TODO: use SZS status instead?
				state = "refutation"
				break
			elif line.startswith("% SZS status Satisfiable"):
				state = "saturation"
				break
			elif line.startswith("User error: "):
				state = "error"
				break
			elif line.startswith("% Termination reason: Refutation not found, non-redundant clauses discarded"):
				state = "timeout"
				break
			elif line.startswith("% Termination reason: Time limit"):
				state = "timeout"
				break
		if state == "none":
			self.vampireState = "error"
		else:
			self.vampireState = state
		return lines

	# start Vampire with manual clause selection on the given input file, until Vampire asks for a clause to select or finishes execution
	# return the output generated before asking for a clause
	def startManualCS(self, inputFile, userOptions):
		if self.vampireProcess != None:
			self.vampireProcess.kill()

		# note: if an option is supplied twice, Vampire ignores the first occurence
		#       we therefore add the user options first, so that user options conflicting
		#       with visualization options are ignored
		args = [self.vampirePath]
		args.extend(userOptions.split())
		args.extend(self.optionsForVisualization)
		args.extend(["--manual_cs", "on", "--time_limit", "0"])
		args.append(inputFile)

		self.vampireProcess = Popen(args, stdin=PIPE, stdout=PIPE, stderr=STDOUT)
		
		newLines = self.collectOutput()
		return newLines

	# perform one clause selection using selectedId
	# return the output generated by that clause selection
	def select(self, selectedId):
		self.vampireProcess.stdin.write(str.encode(str(selectedId) + "\n"))
		self.vampireProcess.stdin.flush()

		newLines = self.collectOutput()
		return newLines

	# helper method
	def collectOutput(self):
		# process lines until a line occurs with either is 1) a commando to enter a number 2) refutation found 3) saturation reached 4) user error
		newLines = []
		line = self.vampireProcess.stdout.readline().decode().rstrip()
		while(True):
			if line.startswith("Pick a clause:"):
				self.vampireState = "running"
				return newLines
			elif line.startswith("% Refutation found. Thanks to"): # TODO: use SZS status instead?
				self.vampireState = "refutation"
				return newLines
			elif line.startswith("% SZS status Satisfiable"):
				self.vampireState = "saturation"
				return newLines
			elif line.startswith("User error: "):
				self.vampireState = "error"
				return newLines
			else:
				newLines.append(line)
				line = self.vampireProcess.stdout.readline().decode().rstrip()

